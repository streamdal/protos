// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `external.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  protolint:disable INDENT
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetServicesRequest)
pub struct GetServicesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetServicesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetServicesRequest {
    fn default() -> &'a GetServicesRequest {
        <GetServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServicesRequest {
    pub fn new() -> GetServicesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetServicesRequest>(
            "GetServicesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetServicesRequest {
    const NAME: &'static str = "GetServicesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetServicesRequest {
        GetServicesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetServicesRequest {
        static instance: GetServicesRequest = GetServicesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetServicesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetServicesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServicesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetServicesResponse)
pub struct GetServicesResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetServicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetServicesResponse {
    fn default() -> &'a GetServicesResponse {
        <GetServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetServicesResponse {
    pub fn new() -> GetServicesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetServicesResponse>(
            "GetServicesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetServicesResponse {
    const NAME: &'static str = "GetServicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetServicesResponse {
        GetServicesResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetServicesResponse {
        static instance: GetServicesResponse = GetServicesResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetServicesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetServicesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServicesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetServiceRequest)
pub struct GetServiceRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetServiceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetServiceRequest {
    fn default() -> &'a GetServiceRequest {
        <GetServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceRequest {
    pub fn new() -> GetServiceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetServiceRequest>(
            "GetServiceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetServiceRequest {
    const NAME: &'static str = "GetServiceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetServiceRequest {
        GetServiceRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetServiceRequest {
        static instance: GetServiceRequest = GetServiceRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetServiceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetServiceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetServiceResponse)
pub struct GetServiceResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetServiceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetServiceResponse {
    fn default() -> &'a GetServiceResponse {
        <GetServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceResponse {
    pub fn new() -> GetServiceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetServiceResponse>(
            "GetServiceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetServiceResponse {
    const NAME: &'static str = "GetServiceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetServiceResponse {
        GetServiceResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetServiceResponse {
        static instance: GetServiceResponse = GetServiceResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetServiceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetServiceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetPipelinesRequest)
pub struct GetPipelinesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetPipelinesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPipelinesRequest {
    fn default() -> &'a GetPipelinesRequest {
        <GetPipelinesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPipelinesRequest {
    pub fn new() -> GetPipelinesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPipelinesRequest>(
            "GetPipelinesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPipelinesRequest {
    const NAME: &'static str = "GetPipelinesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPipelinesRequest {
        GetPipelinesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPipelinesRequest {
        static instance: GetPipelinesRequest = GetPipelinesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPipelinesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPipelinesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPipelinesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPipelinesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetPipelinesResponse)
pub struct GetPipelinesResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetPipelinesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPipelinesResponse {
    fn default() -> &'a GetPipelinesResponse {
        <GetPipelinesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPipelinesResponse {
    pub fn new() -> GetPipelinesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPipelinesResponse>(
            "GetPipelinesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPipelinesResponse {
    const NAME: &'static str = "GetPipelinesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPipelinesResponse {
        GetPipelinesResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPipelinesResponse {
        static instance: GetPipelinesResponse = GetPipelinesResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPipelinesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPipelinesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPipelinesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPipelinesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetPipelineRequest)
pub struct GetPipelineRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetPipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPipelineRequest {
    fn default() -> &'a GetPipelineRequest {
        <GetPipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPipelineRequest {
    pub fn new() -> GetPipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPipelineRequest>(
            "GetPipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPipelineRequest {
    const NAME: &'static str = "GetPipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPipelineRequest {
        GetPipelineRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPipelineRequest {
        static instance: GetPipelineRequest = GetPipelineRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetPipelineResponse)
pub struct GetPipelineResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetPipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPipelineResponse {
    fn default() -> &'a GetPipelineResponse {
        <GetPipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPipelineResponse {
    pub fn new() -> GetPipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPipelineResponse>(
            "GetPipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPipelineResponse {
    const NAME: &'static str = "GetPipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPipelineResponse {
        GetPipelineResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPipelineResponse {
        static instance: GetPipelineResponse = GetPipelineResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.SetPipelineRequest)
pub struct SetPipelineRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.SetPipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPipelineRequest {
    fn default() -> &'a SetPipelineRequest {
        <SetPipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPipelineRequest {
    pub fn new() -> SetPipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPipelineRequest>(
            "SetPipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPipelineRequest {
    const NAME: &'static str = "SetPipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPipelineRequest {
        SetPipelineRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPipelineRequest {
        static instance: SetPipelineRequest = SetPipelineRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.SetPipelineResponse)
pub struct SetPipelineResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.SetPipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPipelineResponse {
    fn default() -> &'a SetPipelineResponse {
        <SetPipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPipelineResponse {
    pub fn new() -> SetPipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPipelineResponse>(
            "SetPipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPipelineResponse {
    const NAME: &'static str = "SetPipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPipelineResponse {
        SetPipelineResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPipelineResponse {
        static instance: SetPipelineResponse = SetPipelineResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.DeletePipelineRequest)
pub struct DeletePipelineRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.DeletePipelineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeletePipelineRequest {
    fn default() -> &'a DeletePipelineRequest {
        <DeletePipelineRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePipelineRequest {
    pub fn new() -> DeletePipelineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeletePipelineRequest>(
            "DeletePipelineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeletePipelineRequest {
    const NAME: &'static str = "DeletePipelineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeletePipelineRequest {
        DeletePipelineRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeletePipelineRequest {
        static instance: DeletePipelineRequest = DeletePipelineRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeletePipelineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeletePipelineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeletePipelineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePipelineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.DeletePipelineResponse)
pub struct DeletePipelineResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.DeletePipelineResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeletePipelineResponse {
    fn default() -> &'a DeletePipelineResponse {
        <DeletePipelineResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeletePipelineResponse {
    pub fn new() -> DeletePipelineResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeletePipelineResponse>(
            "DeletePipelineResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeletePipelineResponse {
    const NAME: &'static str = "DeletePipelineResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeletePipelineResponse {
        DeletePipelineResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeletePipelineResponse {
        static instance: DeletePipelineResponse = DeletePipelineResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeletePipelineResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeletePipelineResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeletePipelineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePipelineResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetStepsRequest)
pub struct GetStepsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetStepsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStepsRequest {
    fn default() -> &'a GetStepsRequest {
        <GetStepsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStepsRequest {
    pub fn new() -> GetStepsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStepsRequest>(
            "GetStepsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStepsRequest {
    const NAME: &'static str = "GetStepsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStepsRequest {
        GetStepsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStepsRequest {
        static instance: GetStepsRequest = GetStepsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStepsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStepsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStepsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStepsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.GetStepsResponse)
pub struct GetStepsResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.GetStepsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStepsResponse {
    fn default() -> &'a GetStepsResponse {
        <GetStepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetStepsResponse {
    pub fn new() -> GetStepsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStepsResponse>(
            "GetStepsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStepsResponse {
    const NAME: &'static str = "GetStepsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStepsResponse {
        GetStepsResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStepsResponse {
        static instance: GetStepsResponse = GetStepsResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStepsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStepsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStepsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.CreateStepRequest)
pub struct CreateStepRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.CreateStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateStepRequest {
    fn default() -> &'a CreateStepRequest {
        <CreateStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateStepRequest {
    pub fn new() -> CreateStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateStepRequest>(
            "CreateStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateStepRequest {
    const NAME: &'static str = "CreateStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateStepRequest {
        CreateStepRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateStepRequest {
        static instance: CreateStepRequest = CreateStepRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.CreateStepResponse)
pub struct CreateStepResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.CreateStepResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateStepResponse {
    fn default() -> &'a CreateStepResponse {
        <CreateStepResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateStepResponse {
    pub fn new() -> CreateStepResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateStepResponse>(
            "CreateStepResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateStepResponse {
    const NAME: &'static str = "CreateStepResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateStepResponse {
        CreateStepResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateStepResponse {
        static instance: CreateStepResponse = CreateStepResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateStepResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateStepResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateStepResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateStepResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.UpdateStepRequest)
pub struct UpdateStepRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.UpdateStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateStepRequest {
    fn default() -> &'a UpdateStepRequest {
        <UpdateStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateStepRequest {
    pub fn new() -> UpdateStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateStepRequest>(
            "UpdateStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateStepRequest {
    const NAME: &'static str = "UpdateStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateStepRequest {
        UpdateStepRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateStepRequest {
        static instance: UpdateStepRequest = UpdateStepRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.UpdateStepResponse)
pub struct UpdateStepResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.UpdateStepResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateStepResponse {
    fn default() -> &'a UpdateStepResponse {
        <UpdateStepResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateStepResponse {
    pub fn new() -> UpdateStepResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateStepResponse>(
            "UpdateStepResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateStepResponse {
    const NAME: &'static str = "UpdateStepResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateStepResponse {
        UpdateStepResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateStepResponse {
        static instance: UpdateStepResponse = UpdateStepResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateStepResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateStepResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateStepResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateStepResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.DeleteStepRequest)
pub struct DeleteStepRequest {
    // special fields
    // @@protoc_insertion_point(special_field:protos.DeleteStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteStepRequest {
    fn default() -> &'a DeleteStepRequest {
        <DeleteStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteStepRequest {
    pub fn new() -> DeleteStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteStepRequest>(
            "DeleteStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteStepRequest {
    const NAME: &'static str = "DeleteStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteStepRequest {
        DeleteStepRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteStepRequest {
        static instance: DeleteStepRequest = DeleteStepRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.DeleteStepResponse)
pub struct DeleteStepResponse {
    // special fields
    // @@protoc_insertion_point(special_field:protos.DeleteStepResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteStepResponse {
    fn default() -> &'a DeleteStepResponse {
        <DeleteStepResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteStepResponse {
    pub fn new() -> DeleteStepResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteStepResponse>(
            "DeleteStepResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteStepResponse {
    const NAME: &'static str = "DeleteStepResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteStepResponse {
        DeleteStepResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteStepResponse {
        static instance: DeleteStepResponse = DeleteStepResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteStepResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteStepResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteStepResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStepResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.TestRequest)
pub struct TestRequest {
    // message fields
    // @@protoc_insertion_point(field:protos.TestRequest.input)
    pub input: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.TestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestRequest {
    fn default() -> &'a TestRequest {
        <TestRequest as ::protobuf::Message>::default_instance()
    }
}

impl TestRequest {
    pub fn new() -> TestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &TestRequest| { &m.input },
            |m: &mut TestRequest| { &mut m.input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestRequest>(
            "TestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestRequest {
    const NAME: &'static str = "TestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.input = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.input);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.input.is_empty() {
            os.write_string(1, &self.input)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestRequest {
        TestRequest::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestRequest {
        static instance: TestRequest = TestRequest {
            input: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:protos.TestResponse)
pub struct TestResponse {
    // message fields
    // @@protoc_insertion_point(field:protos.TestResponse.output)
    pub output: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:protos.TestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestResponse {
    fn default() -> &'a TestResponse {
        <TestResponse as ::protobuf::Message>::default_instance()
    }
}

impl TestResponse {
    pub fn new() -> TestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output",
            |m: &TestResponse| { &m.output },
            |m: &mut TestResponse| { &mut m.output },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestResponse>(
            "TestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestResponse {
    const NAME: &'static str = "TestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.output = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.output);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.output.is_empty() {
            os.write_string(2, &self.output)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestResponse {
        TestResponse::new()
    }

    fn clear(&mut self) {
        self.output.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestResponse {
        static instance: TestResponse = TestResponse {
            output: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12external_api.proto\x12\x06protos\"\x14\n\x12GetServicesRequest\"\
    \x15\n\x13GetServicesResponse\"\x13\n\x11GetServiceRequest\"\x14\n\x12Ge\
    tServiceResponse\"\x15\n\x13GetPipelinesRequest\"\x16\n\x14GetPipelinesR\
    esponse\"\x14\n\x12GetPipelineRequest\"\x15\n\x13GetPipelineResponse\"\
    \x14\n\x12SetPipelineRequest\"\x15\n\x13SetPipelineResponse\"\x17\n\x15D\
    eletePipelineRequest\"\x18\n\x16DeletePipelineResponse\"\x11\n\x0fGetSte\
    psRequest\"\x12\n\x10GetStepsResponse\"\x13\n\x11CreateStepRequest\"\x14\
    \n\x12CreateStepResponse\"\x13\n\x11UpdateStepRequest\"\x14\n\x12UpdateS\
    tepResponse\"\x13\n\x11DeleteStepRequest\"\x14\n\x12DeleteStepResponse\"\
    #\n\x0bTestRequest\x12\x14\n\x05input\x18\x01\x20\x01(\tR\x05input\"&\n\
    \x0cTestResponse\x12\x16\n\x06output\x18\x02\x20\x01(\tR\x06output2\x84\
    \x06\n\x08External\x12F\n\x0bGetServices\x12\x1a.protos.GetServicesReque\
    st\x1a\x1b.protos.GetServicesResponse\x12C\n\nGetService\x12\x19.protos.\
    GetServiceRequest\x1a\x1a.protos.GetServiceResponse\x12I\n\x0cGetPipelin\
    es\x12\x1b.protos.GetPipelinesRequest\x1a\x1c.protos.GetPipelinesRespons\
    e\x12F\n\x0bGetPipeline\x12\x1a.protos.GetPipelineRequest\x1a\x1b.protos\
    .GetPipelineResponse\x12F\n\x0bSetPipeline\x12\x1a.protos.SetPipelineReq\
    uest\x1a\x1b.protos.SetPipelineResponse\x12O\n\x0eDeletePipeline\x12\x1d\
    .protos.DeletePipelineRequest\x1a\x1e.protos.DeletePipelineResponse\x12=\
    \n\x08GetSteps\x12\x17.protos.GetStepsRequest\x1a\x18.protos.GetStepsRes\
    ponse\x12C\n\nCreateStep\x12\x19.protos.CreateStepRequest\x1a\x1a.protos\
    .CreateStepResponse\x12C\n\nUpdateStep\x12\x19.protos.UpdateStepRequest\
    \x1a\x1a.protos.UpdateStepResponse\x12C\n\nDeleteStep\x12\x19.protos.Del\
    eteStepRequest\x1a\x1a.protos.DeleteStepResponse\x121\n\x04Test\x12\x13.\
    protos.TestRequest\x1a\x14.protos.TestResponseB4Z2github.com/streamdal/s\
    nitch-protos/build/go/protosJ\xa5\r\n\x06\x12\x04\0\0E\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x0f\n\x08\n\x01\x08\
    \x12\x03\x04\0I\n\t\n\x02\x08\x0b\x12\x03\x04\0I\n\n\n\x02\x06\0\x12\x04\
    \x06\0'\x01\n\n\n\x03\x06\0\x01\x12\x03\x06\x08\x10\n\"\n\x04\x06\0\x02\
    \0\x12\x03\x08\x02D\x1a\x15\x20Build\x20a\x20service\x20map\n\n\x0c\n\
    \x05\x06\0\x02\0\x01\x12\x03\x08\x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\
    \x03\x08\x12$\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x08/B\nX\n\x04\x06\0\
    \x02\x01\x12\x03\x0b\x02A\x1aK\x20Figure\x20out\x20consumers/producers,\
    \x20pipelines\x20and\x20targets\x20for\x20a\x20given\x20service\n\n\x0c\
    \n\x05\x06\0\x02\x01\x01\x12\x03\x0b\x06\x10\n\x0c\n\x05\x06\0\x02\x01\
    \x02\x12\x03\x0b\x11\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x0b-?\n*\n\
    \x04\x06\0\x02\x02\x12\x03\x0e\x02G\x1a\x1d\x20Get\x20all\x20available\
    \x20pipelines\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x0e\x06\x12\n\x0c\
    \n\x05\x06\0\x02\x02\x02\x12\x03\x0e\x13&\n\x0c\n\x05\x06\0\x02\x02\x03\
    \x12\x03\x0e1E\n-\n\x04\x06\0\x02\x03\x12\x03\x11\x02D\x1a\x20\x20Get\
    \x20a\x20pipeline\x20(and\x20its\x20steps)\n\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03\x11\x06\x11\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x11\x12$\
    \n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x11/B\n`\n\x04\x06\0\x02\x04\x12\
    \x03\x14\x02D\x1aS\x20Associate\x20steps\x20with\x20a\x20pipeline\x20//\
    \x20Can\x20also\x20use\x20this\x20to\x20set\x20steps\x20in\x20one\x20big\
    \x20push\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x14\x06\x11\n\x0c\n\x05\
    \x06\0\x02\x04\x02\x12\x03\x14\x12$\n\x0c\n\x05\x06\0\x02\x04\x03\x12\
    \x03\x14/B\n\x20\n\x04\x06\0\x02\x05\x12\x03\x17\x02M\x1a\x13\x20Delete\
    \x20a\x20pipeline\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x17\x06\x14\n\
    \x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x17\x15*\n\x0c\n\x05\x06\0\x02\x05\
    \x03\x12\x03\x175K\n3\n\x04\x06\0\x02\x06\x12\x03\x1a\x02;\x1a&\x20Get\
    \x20steps\x20associated\x20with\x20a\x20pipeline\n\n\x0c\n\x05\x06\0\x02\
    \x06\x01\x12\x03\x1a\x06\x0e\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03\x1a\
    \x0f\x1e\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x1a)9\n\x1c\n\x04\x06\0\
    \x02\x07\x12\x03\x1d\x02A\x1a\x0f\x20Create\x20a\x20step\n\n\x0c\n\x05\
    \x06\0\x02\x07\x01\x12\x03\x1d\x06\x10\n\x0c\n\x05\x06\0\x02\x07\x02\x12\
    \x03\x1d\x11\"\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03\x1d-?\n\x1c\n\x04\
    \x06\0\x02\x08\x12\x03\x20\x02A\x1a\x0f\x20Update\x20a\x20step\n\n\x0c\n\
    \x05\x06\0\x02\x08\x01\x12\x03\x20\x06\x10\n\x0c\n\x05\x06\0\x02\x08\x02\
    \x12\x03\x20\x11\"\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03\x20-?\n\x1c\n\
    \x04\x06\0\x02\t\x12\x03#\x02A\x1a\x0f\x20Delete\x20a\x20step\n\n\x0c\n\
    \x05\x06\0\x02\t\x01\x12\x03#\x06\x10\n\x0c\n\x05\x06\0\x02\t\x02\x12\
    \x03#\x11\"\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03#-?\n\x1a\n\x04\x06\0\x02\
    \n\x12\x03&\x02/\x1a\r\x20Test\x20method\n\n\x0c\n\x05\x06\0\x02\n\x01\
    \x12\x03&\x06\n\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03&\x0b\x16\n\x0c\n\x05\
    \x06\0\x02\n\x03\x12\x03&!-\n%\n\x02\x04\0\x12\x03*\0\x1d\x1a\x1a\x20pro\
    tolint:disable\x20INDENT\n\n\n\n\x03\x04\0\x01\x12\x03*\x08\x1a\n\t\n\
    \x02\x04\x01\x12\x03+\0\x1e\n\n\n\x03\x04\x01\x01\x12\x03+\x08\x1b\n\t\n\
    \x02\x04\x02\x12\x03,\0\x1c\n\n\n\x03\x04\x02\x01\x12\x03,\x08\x19\n\t\n\
    \x02\x04\x03\x12\x03-\0\x1d\n\n\n\x03\x04\x03\x01\x12\x03-\x08\x1a\n\t\n\
    \x02\x04\x04\x12\x03.\0\x1e\n\n\n\x03\x04\x04\x01\x12\x03.\x08\x1b\n\t\n\
    \x02\x04\x05\x12\x03/\0\x1f\n\n\n\x03\x04\x05\x01\x12\x03/\x08\x1c\n\t\n\
    \x02\x04\x06\x12\x030\0\x1d\n\n\n\x03\x04\x06\x01\x12\x030\x08\x1a\n\t\n\
    \x02\x04\x07\x12\x031\0\x1e\n\n\n\x03\x04\x07\x01\x12\x031\x08\x1b\n\t\n\
    \x02\x04\x08\x12\x032\0\x1d\n\n\n\x03\x04\x08\x01\x12\x032\x08\x1a\n\t\n\
    \x02\x04\t\x12\x033\0\x1e\n\n\n\x03\x04\t\x01\x12\x033\x08\x1b\n\t\n\x02\
    \x04\n\x12\x034\0\x20\n\n\n\x03\x04\n\x01\x12\x034\x08\x1d\n\t\n\x02\x04\
    \x0b\x12\x035\0!\n\n\n\x03\x04\x0b\x01\x12\x035\x08\x1e\n\t\n\x02\x04\
    \x0c\x12\x036\0\x1a\n\n\n\x03\x04\x0c\x01\x12\x036\x08\x17\n\t\n\x02\x04\
    \r\x12\x037\0\x1b\n\n\n\x03\x04\r\x01\x12\x037\x08\x18\n\t\n\x02\x04\x0e\
    \x12\x038\0\x1c\n\n\n\x03\x04\x0e\x01\x12\x038\x08\x19\n\t\n\x02\x04\x0f\
    \x12\x039\0\x1c\n\n\n\x03\x04\x0f\x01\x12\x039\x08\x1a\n\t\n\x02\x04\x10\
    \x12\x03:\0\x1c\n\n\n\x03\x04\x10\x01\x12\x03:\x08\x19\n\t\n\x02\x04\x11\
    \x12\x03;\0\x1d\n\n\n\x03\x04\x11\x01\x12\x03;\x08\x1a\n\t\n\x02\x04\x12\
    \x12\x03<\0\x1c\n\n\n\x03\x04\x12\x01\x12\x03<\x08\x19\n\t\n\x02\x04\x13\
    \x12\x03=\0\x1d\n\n\n\x03\x04\x13\x01\x12\x03=\x08\x1a\n\n\n\x02\x04\x14\
    \x12\x04?\0A\x01\n\n\n\x03\x04\x14\x01\x12\x03?\x08\x13\n\x0b\n\x04\x04\
    \x14\x02\0\x12\x03@\x02\x13\n\x0c\n\x05\x04\x14\x02\0\x05\x12\x03@\x02\
    \x08\n\x0c\n\x05\x04\x14\x02\0\x01\x12\x03@\t\x0e\n\x0c\n\x05\x04\x14\
    \x02\0\x03\x12\x03@\x11\x12\n\n\n\x02\x04\x15\x12\x04C\0E\x01\n\n\n\x03\
    \x04\x15\x01\x12\x03C\x08\x14\n\x0b\n\x04\x04\x15\x02\0\x12\x03D\x02\x14\
    \n\x0c\n\x05\x04\x15\x02\0\x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\x15\x02\
    \0\x01\x12\x03D\t\x0f\n\x0c\n\x05\x04\x15\x02\0\x03\x12\x03D\x12\x13b\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(22);
            messages.push(GetServicesRequest::generated_message_descriptor_data());
            messages.push(GetServicesResponse::generated_message_descriptor_data());
            messages.push(GetServiceRequest::generated_message_descriptor_data());
            messages.push(GetServiceResponse::generated_message_descriptor_data());
            messages.push(GetPipelinesRequest::generated_message_descriptor_data());
            messages.push(GetPipelinesResponse::generated_message_descriptor_data());
            messages.push(GetPipelineRequest::generated_message_descriptor_data());
            messages.push(GetPipelineResponse::generated_message_descriptor_data());
            messages.push(SetPipelineRequest::generated_message_descriptor_data());
            messages.push(SetPipelineResponse::generated_message_descriptor_data());
            messages.push(DeletePipelineRequest::generated_message_descriptor_data());
            messages.push(DeletePipelineResponse::generated_message_descriptor_data());
            messages.push(GetStepsRequest::generated_message_descriptor_data());
            messages.push(GetStepsResponse::generated_message_descriptor_data());
            messages.push(CreateStepRequest::generated_message_descriptor_data());
            messages.push(CreateStepResponse::generated_message_descriptor_data());
            messages.push(UpdateStepRequest::generated_message_descriptor_data());
            messages.push(UpdateStepResponse::generated_message_descriptor_data());
            messages.push(DeleteStepRequest::generated_message_descriptor_data());
            messages.push(DeleteStepResponse::generated_message_descriptor_data());
            messages.push(TestRequest::generated_message_descriptor_data());
            messages.push(TestResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
